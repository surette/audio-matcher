#!/usr/bin/python
import sys
import os
import math
import numpy as np
import wave
import struct
import subprocess

# checks to see if the two wave files are exactly the same
def match(fpath1 = None, fpath2 = None):
    verifyPathToFile(fpath1)
    verifyPathToFile(fpath2)
    file1 = None
    file2 = None

    # extrach the name of the file
    name1 = fpath1.rpartition('/')[2].split('.')[0]
    name2 = fpath2.rpartition('/')[2].split('.')[0]

    # check if any of the files is mp3 file. If it is, convert it to wav
    if(isMp3(fpath1)):
       	fpath1 = convertToWav(fpath1, name1)
    if(isMp3(fpath2)):
       	fpath2 = convertToWav(fpath2, name2)

    # makes sure the files are actually wave files
    (file1, file2) = open_wave_files(fpath1, fpath2)

    # converts the audio data into mono
    file1 = convertToMono(file1, name1)
    file2 = convertToMono(file2, name2)

    # converts the audio data to frequencies
    file1_freq = fftconvert(file1)
    file2_freq = fftconvert(file2)

    # close the files now
    file1.close()
    file2.close()

    # get a list of tuple of significant magnitudes for second
    file1_mag = significantMags(file1_freq)
    file2_mag = significantMags(file2_freq)

    # compare the two arrays of frequencies
    if compare(file1_mag, file2_mag):
       	return True
    else:
       	return False

# make sure there is the correct number of arguments given
def verifyArgs():
   #verify that there are the correct number of arguements
   if len(sys.argv) != 5:
      sys.stderr.write("ERROR: Wrong number of arguments\n")
      exit(1)
   # Verify that all the flags are correct
   if sys.argv[1] != '-f' or sys.argv[3] != '-f':
      sys.stderr.write("ERROR: Incorrect Flags\n")
      exit(3)

# make sure the input is a real file
def verifyPathToFile(path):
   if not os.path.isfile(path):
      sys.stderr.write("ERROR: Path "+path+" is invalid/is not a file\n")
      exit(2)

# checks whether the file is mp3 or not
def isMp3(fpath):
   return fpath.lower().endswith('.mp3')

# converts the given mp3 file to wav file and saves it to /tmp,
# it returns the wav file's path
def convertToWav(fpath, name):
    newName = "/tmp/" + name + '.wav' #fpath.replace(fpath, ".mp3", ".wav")
    cmd = "/course/cs4500f13/bin/lame --decode "+ fpath + " " + newName
    subprocess.call(cmd, shell=True)
    return newName

def open_wave_files(fpath1, fpath2):
    try:
        file1 = wave.open(fpath1, 'r')
        file2 = wave.open(fpath2, 'r')
	return file1, file2
    except wave.Error:
        sys.stderr.write("ERROR: File is not using the correct .wav format\n")
        exit(3)
    except:
        sys.stderr.write("ERROR: Error opening files\n")
        exit(4)

# if the audio file is not a mono channel, change it to mono and return it,
# otherwise, return the same file
def convertToMono(audio, name):
    #store attributes of wav file
    (nchannels, sampwidth, framerate, nframes, comptype, compname) = \
    audio.getparams()

    if nchannels != 1:
        newName = "/tmp/mono-" + name + ".wav"
        newAudio = wave.open(newName, 'w')
	newAudio.setparams((1,  sampwidth, framerate, nframes, comptype, compname))

	for i in range(0, nframes):
            waveData = audio.readframes(1)
            unPack = wave.struct.unpack(getFormat(nchannels, sampwidth), waveData)
            average = (unPack[0] + unPack[1])/2
            newAudio.writeframes(wave.struct.pack(getFormat(1, sampwidth), average))

        audio.close()
        newAudio.close()
        newAudio = wave.open(newName, 'r')
        return newAudio
    else:
        return audio

# gets the format of the file based on size of sample and sample width
#  8 bits: size + "b"
# 16 bits: size + "h"
def getFormat(sampsize, sampwidth):
    fmt = str(sampsize)
    if sampwidth == 1:
        fmt = fmt + 'b'
    else:
        fmt = fmt + 'h'
    return fmt

def fftconvert(audio):
    # store attributes of wav file
    (nchannels, sampwidth, framerate, nframes, comptype, compname) \
    = audio.getparams()

    # the result array of fft for each second
    ffta = []
    for i in range(0, nframes/framerate):
        waveData = audio.readframes(framerate)
        unPack = wave.struct.unpack_from(getFormat(framerate, sampwidth), waveData)
        mags = abs(np.fft.fft(unPack))**2
        freqs = np.fft.fftfreq(framerate)
        ffta.append(zip(mags, freqs))

    # return the array of frequencies
    return ffta

def significantMags(fft):
   result = []
   for sec in fft:
      tup = highestMag(sec)
      result.append(tup)

   return result

# fft1 and fft2 are arrays of tuples of highest mags defined in
# significiantMags
def compare(fft1, fft2):
    if len(fft1) < len(fft2):
        return isSubset(fft1, fft2)
    else:
        return isSubset(fft2, fft1)

# assumes list1 is the child/subset
def isSubset(list1, list2):
    for val1 in list1:
	found = False
        for val2 in list2:
	    if eachisclose(val1, val2):
                found = True
                break
	if not found:
            return False
    return True

# creates tolerance for acceptance as a derived file
def eachisclose(val1,val2):
   for v1, v2 in zip(val1, val2):
      ratio = 1
      if v1 > v2:
         ratio = v2/v1
      else:
         ratio = v1/v2
      if ratio < 0.75:
         return False
   return True

# takes a chunk and returns a tuple of highest value within each of 4 buckets
# Returns: [#,#,#,#]
def highestMag(sec):
    # bucket1: -0.5, -0.25
    # bucket2: -0.25, 0
    # bucket3: 0, 0.25
    # bucket4: 0.25, 0.5
    bound0 = -0.5
    bound1 = -0.25
    bound2 = 0
    bound3 = 0.25
    bound4 = 0.5

    max_bucket1, max_bucket2, max_bucket3, max_bucket4 = \
    -0.5, -0.5, -0.5, -0.5

    # loop through the chunk, determining the the magnitude is a max in
    # any of the buckets
    for mag, freq in sec:
        if bound0 <= freq < bound1:
            if mag > max_bucket1:
                max_bucket1 = mag
        elif bound1 <= freq < bound2:
            if mag > max_bucket2:
                max_bucket2 = mag
        elif bound2 <= freq < bound3:
            if mag > max_bucket3:
                max_bucket3 = mag
        elif bound3 <= freq <= bound4:
            if mag > max_bucket4:
                max_bucket4 = mag

    return max_bucket1, max_bucket2, max_bucket3, max_bucket4

if __name__ == '__main__':
   verifyArgs()
   matches = match(sys.argv[2], sys.argv[4])
   if matches:
      print "MATCH"
   else:
      print "NO MATCH"
   exit(0)
