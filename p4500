#!/usr/bin/python
import sys
import os
import math
import shutil
import numpy as np
import wave
import struct
import subprocess
import uuid
from mutagen.mp3 import MP3, HeaderNotFoundError


# global variables
TOLERANCE = 1
PERCENT_RATIO = 0.60
TMP_FOLDER = "/tmp/zaFile" + "-" + str(uuid.uuid4().hex) + "/"
FPATH_DICT = dict()
EXIT_CODE = 0

# handles converting input into our canonical format
class Audio:
    def __init__(self, fpath):
        self.fpath = fpath
        self.wavData = self.createCanonicalForm()

    # performs checks and mono conversions on audio file, 
    # returns opened mono wav file
    def createCanonicalForm(self):
        # extract the name of the file
        name = self.fpath.rpartition('/')[2].split('.')[0] + "-" + \
        str(uuid.uuid4().hex)
        
        path = self.fpath;

        # if a file is an mp3 but does not have a .mp3 extension,
        # create a file in the tmp directory that takes the input file and
        # changes its extension to .mp3
        if isMp3(path) and path.rsplit('.')[0] != '.mp3':
            path = self.toExtension(name, '.mp3')

        if isWav(path) and path.rsplit('.')[0] != '.wav':
            path = self.toExtension(name, '.wav')

        # check if any of the files is mp3 file. If it is, convert it to wav
        if isMp3(path) or isWav(path):
            wav_fpath = self.convertToMonoWav(path, name)

        # makes sure the files are actually wave files
        wav_file = self.open_wav_file(wav_fpath)

        return wav_file

    # create a file in the tmp directory that takes the input file and
    # changes its extension to .mp3
    def toExtension(self, name, ext):
        newPath = TMP_FOLDER + name + "_" + str(uuid.uuid4().hex) + ext
        cmd = "cp " + self.fpath + " " + newPath

        subprocess.call(cmd, shell=True)

        return newPath

    # Converts an audio file to a mono wav file using lame
    # RETURNS: the wav file's path
    def convertToMonoWav(self, fpath, name):
        #convert mp3 to mono mp3
        mono = TMP_FOLDER + name + "_" + str(uuid.uuid4().hex) + "_mono.mp3"
        cmd = "/course/cs4500f13/bin/lame -a --silent -q2 -b 16 " + \
        "--resample 22050 " + fpath + " " + mono
        
        subprocess.call(cmd, shell=True)

        #convert to wav
        newName = TMP_FOLDER + name + "_" + str(uuid.uuid4().hex) + '.wav'
        cmd = "/course/cs4500f13/bin/lame --decode --silent -q2 " \
        + mono + " " + newName

        subprocess.call(cmd, shell=True)
        # print "converted"
        return newName

    # opens wav file using wave audio library
    def open_wav_file(self, fpath):
        try:
            wav_file = wave.open(fpath, 'r')
            return wav_file
        except wave.Error:
            fancyExit("File is not using a correct audio format", 3)
        except:
            fancyExit("Error opening file ", 4)

# creates and stores identifying vector for input audio
class Fingerprint:
    def __init__(self, fpath, wavData):
        self.fpath = fpath
        self.fingerprint = self.processFingerprint(wavData)
        (self.nchannels, self.sampwidth, self.framerate, self.nframes, \
        self.comptype, self.compname) = wavData.getparams()

    # creates fingerprint from wav data
    def processFingerprint(self, wavData):
        fft = self.fftconvert(wavData)

        return self.createFingerprints(fft)

    # runs the fft on smaller chunks of the input audio
    def fftconvert(self, audio):
        # print "in FFT"
        # store attributes of wav file
        (nchannels, sampwidth, framerate, nframes, comptype, compname) \
        = audio.getparams()

        # the result array of fft for each tenth of a second
        ffta = []
        chunksize = framerate/10

        # LOOP INVARIANT:
        # 0 <= i <= nframes/framerate
        # ffta is the combination of the magnitudes 
        # and frequencies of each chunk
        for i in range(0, nframes/chunksize):
            wavData = audio.readframes(chunksize)
            unPack = wave.struct.unpack_from(getFormat(chunksize, sampwidth), \
            wavData)

            mags = abs(np.fft.fft(unPack))
            freqs = abs(np.fft.fftfreq(chunksize)*chunksize)
            ffta.append(zip(mags, freqs))

        # return the array of frequencies
        return ffta

    # return an array of tuples consisting of the significant values at each
    # second in the file
    def createFingerprints(self, fft):
        fingerprint = []

        # tup is a tuple of the highest values at each second
        for sec in fft:
            tup = self.significantValues(sec)
            fingerprint.append(tup)

        return fingerprint

    # takes a chunk and returns a tuple of highest value 
    # within each of 4 buckets
    # Returns: [#,#,#,#]
    def significantValues(self, sec):
        # bucket1: 0, 4000
        # bucket2: 4000, 8000
        # bucket3: 8000, 12000
        # bucket4: 12000, 15000
        bound0 = 0
        bound1 = 4000
        bound2 = 8000
        bound3 = 12000
        bound4 = 15000

        max_bucket1, max_bucket2, max_bucket3, max_bucket4 = \
        0, 0, 0, 0
        
        max_mag_bucket1, max_mag_bucket2, max_mag_bucket3, max_mag_bucket4 = \
        0, 0, 0, 0

        # loop through the chunk, determining the the magnitude is a max in
        # any of the buckets
        for mag, freq in sec:
            if bound0 <= freq < bound1:
                if mag > max_mag_bucket1:
                    max_mag_bucket1 = mag
                    max_bucket1 = freq
            elif bound1 <= freq < bound2:
                if mag > max_mag_bucket2:
                    max_mag_bucket2 = mag
                    max_bucket2 = freq
            elif bound2 <= freq < bound3:
                if mag > max_mag_bucket3:
                    max_mag_bucket3 = mag
                    max_bucket3 = freq
            elif bound3 <= freq <= bound4:
                if mag > max_mag_bucket4:
                    max_mag_bucket4 = mag
                    max_bucket4 = freq

        return max_bucket1, max_bucket2, max_bucket3, max_bucket4

# check all matches between list1 and list2
def allMatch(list1, list2):
    for path1 in list1:
        for path2 in list2:
            name1 = path1.rpartition('/')[2]
            name2 = path2.rpartition('/')[2]

            if isSupportedFileType(path1) and isSupportedFileType(path2):
                if match(path1, path2):
                    if len(FPATH_DICT[path1].fingerprint) < \
                    len(FPATH_DICT[path2].fingerprint):
                        print "MATCH " + name1 + " " + name2
                    else:
                        print "MATCH " + name2 + " " + name1
                else:
                    if len(FPATH_DICT[path1].fingerprint) < \
                    len(FPATH_DICT[path2].fingerprint):
                        print "NO MATCH " + name1 + " " + name2
                    else:
                        print "NO MATCH " + name2 + " " + name1
            else:
                sys.stderr.write("ERROR: Not a Supported File Type\n")
                EXIT_CODE = 10 

# checks to see if the two wav files are exactly the same
def match(fpath1 = None, fpath2 = None):
    verifyPathToFile(fpath1)
    verifyPathToFile(fpath2)

    fingerprint1 = getFingerprint(fpath1)
    fingerprint2 = getFingerprint(fpath2)

    # compare the two arrays of frequencies
    return compare(fingerprint1.fingerprint, fingerprint2.fingerprint)

# If the file path is not in the dictionary, create it and add it,
# then return the fingerprint of the file path.
def getFingerprint(fpath):
    if fpath not in FPATH_DICT:
        audio = Audio(fpath)
        fingerprint = Fingerprint(fpath, audio.wavData)
        FPATH_DICT[fpath] = fingerprint
    
    return FPATH_DICT[fpath]

def isSupportedFileType(fpath):
    return isWav(fpath) or isMp3(fpath)

def isWav(fpath):
    cmd = "file " + fpath
    output = subprocess.Popen([cmd], stdout = subprocess.PIPE, \
    stderr = subprocess.STDOUT, shell=True).communicate()[0]
    
    return "WAVE" in output

def isMp3(fpath):
    cmd = "file " + fpath
    output = subprocess.Popen([cmd], stdout = subprocess.PIPE, stderr = \
    subprocess.STDOUT, shell=True).communicate()[0]
    
    return ("MPEG ADTS, layer III" in output) or ("MP3" in output)

# make sure there is the correct number of arguments given
def verifyArgs():

    # Verify that there are the correct number of arguments
    if len(sys.argv) != 5:
        fancyExit("Wrong number of arguments", 1)

    # Verify that all the flags are correct
    if ((sys.argv[1] != '-f' and sys.argv[1] != '-d') or 
       (sys.argv[3] != '-f' and sys.argv[3] != '-d')):
        fancyExit("Incorrect Flags", 3)

    if   (sys.argv[1] == '-f'):
        verifyPathToFile(sys.argv[2])
    elif (sys.argv[1] == '-d'):
        verifyPathToDir(sys.argv[2])

    if   (sys.argv[3] == '-f'):
        verifyPathToFile(sys.argv[4])
    elif (sys.argv[3] == '-d'):
        verifyPathToDir(sys.argv[4])

# create lists of filepaths of inputs
def parseArgs():

    # hold names of all filepaths to be compared
    fpaths1 = getPaths(sys.argv[1], sys.argv[2])
    fpaths2 = getPaths(sys.argv[3], sys.argv[4])

    return fpaths1, fpaths2

# obtains filepaths
def getPaths(flag, path):

    fpaths = list()

    if (flag == '-f'):
        fpaths.append(path)
    else:
        # obtains list of all the short names of files in directory
        for (dirpath, dirnames, filenames) in os.walk(path):
            fnames = filenames
            fpaths = [os.path.join(path, name) for name in fnames]
            # if there is a subdirectory in the target directory, print an error and 
            # continue execution with any actual files found
            if dirnames:
                sys.stderr.write("ERROR: At least one subdirectory detected in " + \
                    path + ". Files in subdirectories are not matched.\n")
                EXIT_CODE = 12

            break
            
    return fpaths
    
# make sure that the directory in tmp exists, create it otherwise
def verifyTmp():
    if not os.path.exists(TMP_FOLDER):
        os.mkdir(TMP_FOLDER)

# clean the tmp directory by removing any tmp files in our tmp folder
def cleanTmp():
    shutil.rmtree(TMP_FOLDER)

# make sure the input is a real file
def verifyPathToFile(path):
    if not os.path.isfile(path):
        fancyExit("Path " + path + " is invalid/is not a file", 2)

def verifyPathToDir(path):
    if not os.path.isdir(path):
        fancyExit("Path " + path + "is invalid/is not a Directory", 2)

# gets the format of the file based on size of sample and sample width
#  8 bits: size + "b"
# 16 bits: size + "h"
def getFormat(sampsize, sampwidth):
    fmt = str(sampsize)
    if sampwidth == 1:
        fmt = fmt + 'b'
    else:
        fmt = fmt + 'h'
    return fmt

# fft1 and fft2 are arrays of tuples of highest mags defined in
# createFingerprints
def compare(fft1, fft2):
    if len(fft1) <= len(fft2):
        return isSubset(fft1, fft2)
    else:
        return isSubset(fft2, fft1)

# assumes list1 is the child/subset
def isSubset(list1, list2):
    # print "in matching isSubset"
    count = 0
    val1 = list1[0]

    for i2, val2 in enumerate(list2):
        # check if there are enough pieces for it to be a match
        if len(list1) > len(list2) - i2:
            break

        #if distance(val1, val2) <= TOLERANCE:
        count = checkSequence(list1, list2, i2) + 1
        if closeRatio(count, len(list1)):
            return True

    return False

# checks if list1 is close to list2 starting from ind 
def checkSequence(list1, list2, ind):
    count = 0
    
    # i is the index for list 1, it starts from 0 to len(list1)
    # j is the index for list 2, it starts from ind to len(list1)+ind 
    for i, j in enumerate(range(ind, len(list1)+ind)):
        if distance(list1[i], list2[j]) <= TOLERANCE:
            count = count + 1

    return count

# distance function that uses euclidean formula to get the
# distance between the two given tuples
# - assumes tuple1 and tuple2 are of the same size
def distance(tuple1, tuple2):
    underroot = 0
    for i in range(0, len(tuple1)): 
        underroot = underroot + math.pow(tuple1[i] - tuple2[i], 2)
    
    dist = math.sqrt(underroot)
    #print(dist)
    return dist

# creates tolerance for acceptance as a derived file using a ratio
def closeRatio(val1,val2):
    val1 = float(val1)
    val2 = float(val2)
    ratio = 1.0
    if val1 > val2:
        ratio = val2/val1
    else:
        ratio = val1/val2

    #print ratio
    if ratio < PERCENT_RATIO:
        return False
    return True

# Custom Exit method for days
def fancyExit(message, code):
    if message != "":
        sys.stderr.write("ERROR: " + message + "\n")

    cleanTmp()
    exit(code)

if __name__ == '__main__':
    verifyTmp()
    verifyArgs()
    fpaths1, fpaths2 = parseArgs()

    allMatch(fpaths1, fpaths2)
    
    fancyExit("", EXIT_CODE)
