#!/usr/bin/python
import sys
import os
import math
import shutil
import numpy as np
import wave
import struct
import subprocess
import uuid
from mutagen.mp3 import MP3, HeaderNotFoundError


# global variables
TOLERANCE = 1
PERCENT_RATIO = 0.80
TMP_FOLDER = "/tmp/zaFile" + str(uuid.uuid4().hex) + "/"
FPATH_DICT = dict()

# handles converting input into our canonical format
class Audio:
    def __init__(self, fpath):
        self.fpath = fpath
        self.wavData = self.createCanonicalForm()

    # performs checks and mono conversions on audio file, 
    # returns opened mono wav file
    def createCanonicalForm(self):
        # extract the name of the file
        name = self.fpath.rpartition('/')[2].split('.')[0] + str(uuid.uuid4().hex)

        # check if any of the files is mp3 file. If it is, convert it to wav
        if(self.isMp3(self.fpath)):
            wav_fpath = self.convertToWav(self.fpath, name)
        else:
            wav_fpath = self.fpath

        # makes sure the files are actually wave files
        wav_file = self.open_wav_file(wav_fpath)

        # converts the audio data into mono
        mono_file = self.convertToMono(wav_file, name)

        wav_file.close()

        return mono_file

    # checks whether the file is mp3 or not
    def isMp3(self, fpath):
        try:
            audio = MP3(fpath)
            return not audio.info.sketchy
        except HeaderNotFoundError:
            sys.stderr.write("ERROR: File "+fpath+" is unsupported\n")
            exit(5)

    # converts the given mp3 file to wav file and saves it to /tmp,
    # it returns the wav file's path
    def convertToWav(self, fpath, name):
        newName = TMP_FOLDER + name + '.wav'
        cmd = "/course/cs4500f13/bin/lame --decode --silent " \
        + fpath + " " + newName

        subprocess.call(cmd, shell=True)
        return newName

    # opens wav file using wave audio library
    def open_wav_file(self, fpath):
        try:
            wav_file = wave.open(fpath, 'r')
            return wav_file
        except wave.Error:
            sys.stderr.write("ERROR: File is not using the correct .wav format\n")
            exit(3)
        except:
            sys.stderr.write("ERROR: Error opening files\n")
            exit(4)

    # if the audio file is not a mono channel, change it to mono and return it,
    # otherwise, return the same file
    def convertToMono(self, audio, name):
        #store attributes of wav file
        (nchannels, sampwidth, framerate, nframes, comptype, compname) = \
        audio.getparams()

        if nchannels != 1:
            newName = TMP_FOLDER + "mono-" + name + ".wav"
            newAudio = wave.open(newName, 'w')
            newAudio.setparams((1,  sampwidth, framerate, nframes, \
            comptype, compname))

            # LOOP INVARIANT:
            # 0 <= i <= nframes
            # newAudio has frames written to it consisting of the average of the
            # two channels from i frames from old audio
            for i in range(0, nframes):
                wavData = audio.readframes(1)
                unPack = wave.struct.unpack(getFormat(nchannels, sampwidth), \
                wavData)

                average = (unPack[0] + unPack[1])/2
                newAudio.writeframes(wave.struct.pack(getFormat(1, sampwidth), \
                average))

            audio.close()
            newAudio.close()
            newAudio = wave.open(newName, 'r')
            return newAudio
        else:
            return audio

# creates and stores identifying vector for input audio
class Fingerprint:
    def __init__(self, fpath, wavData):
        self.fpath = fpath
        self.fingerprint = self.processFingerprint(wavData)
        (self.nchannels, self.sampwidth, self.framerate, self.nframes, \
        self.comptype, self.compname) = wavData.getparams()

    # creates fingerprint from wav data
    def processFingerprint(self, wavData):
        fft = self.fftconvert(wavData)

        return self.createFingerprints(fft)

    # runs the fft on smaller chunks of the input audio
    def fftconvert(self, audio):
        # store attributes of wav file
        (nchannels, sampwidth, framerate, nframes, comptype, compname) \
        = audio.getparams()

        # the result array of fft for each tenth of a second
        ffta = []
        chunksize = framerate/10

        # LOOP INVARIANT:
        # 0 <= i <= nframes/framerate
        # ffta is the combination of the magnitudes and frequencies of each chunk
        for i in range(0, nframes/chunksize):
            wavData = audio.readframes(chunksize)
            unPack = wave.struct.unpack_from(getFormat(chunksize, sampwidth), \
            wavData)

            mags = abs(np.fft.fft(unPack))
            freqs = abs(np.fft.fftfreq(chunksize)*chunksize)
            ffta.append(zip(mags, freqs))

        # return the array of frequencies
        return ffta

    # return an array of tuples consisting of the significant values at each
    # second in the file
    def createFingerprints(self, fft):
        fingerprint = []

        # tup is a tuple of the highest values at each second
        for sec in fft:
            tup = self.significantValues(sec)
            fingerprint.append(tup)

        return fingerprint

    # takes a chunk and returns a tuple of highest value within each of 4 buckets
    # Returns: [#,#,#,#]
    def significantValues(self, sec):
        # bucket1: 0, 4000
        # bucket2: 4000, 8000
        # bucket3: 8000, 12000
        # bucket4: 12000, 15000
        bound0 = 0
        bound1 = 4000
        bound2 = 8000
        bound3 = 12000
        bound4 = 15000

        max_bucket1, max_bucket2, max_bucket3, max_bucket4 = \
        0, 0, 0, 0
        
        max_mag_bucket1, max_mag_bucket2, max_mag_bucket3, max_mag_bucket4 = \
        0, 0, 0, 0

        # loop through the chunk, determining the the magnitude is a max in
        # any of the buckets
        for mag, freq in sec:
            if bound0 <= freq < bound1:
                if mag > max_mag_bucket1:
                    max_mag_bucket1 = mag
                    max_bucket1 = freq
            elif bound1 <= freq < bound2:
                if mag > max_mag_bucket2:
                    max_mag_bucket2 = mag
                    max_bucket2 = freq
            elif bound2 <= freq < bound3:
                if mag > max_mag_bucket3:
                    max_mag_bucket3 = mag
                    max_bucket3 = freq
            elif bound3 <= freq <= bound4:
                if mag > max_mag_bucket4:
                    max_mag_bucket4 = mag
                    max_bucket4 = freq

        return max_bucket1, max_bucket2, max_bucket3, max_bucket4

# check all matches between list1 and list2
def allMatch(list1, list2):
    for path1 in list1:
        for path2 in list2:
            name1 = path1.rpartition('/')[2]
            name2 = path2.rpartition('/')[2]
            if match(path1, path2):
                if len(FPATH_DICT[path1].fingerprint) < len(FPATH_DICT[path2].fingerprint):
                    print "MATCH " + name1 + " " + name2
                else:
                    print "MATCH " + name2 + " " + name1
            else:
                print "NO MATCH " + name1 + " " + name2

# checks to see if the two wav files are exactly the same
def match(fpath1 = None, fpath2 = None):
    verifyPathToFile(fpath1)
    verifyPathToFile(fpath2)

    fingerprint1 = getFingerprint(fpath1)
    fingerprint2 = getFingerprint(fpath2)

    # compare the two arrays of frequencies
    return compare(fingerprint1.fingerprint, fingerprint2.fingerprint)

# If the file path is not in the dictionary, create it and add it,
# then return the fingerprint of the file path.
def getFingerprint(fpath):
    if fpath not in FPATH_DICT:
        audio = Audio(fpath)
        fingerprint = Fingerprint(fpath, audio.wavData)
        FPATH_DICT[fpath] = fingerprint
    
    return FPATH_DICT[fpath]

# make sure there is the correct number of arguments given
def verifyArgs():

    # Verify that there are the correct number of arguments
    if len(sys.argv) != 5:
        sys.stderr.write("ERROR: Wrong number of arguments\n")
        exit(1)
    # Verify that all the flags are correct
    if (sys.argv[1] != '-f' or sys.argv[1] != '-d' 
            or sys.argv[3] != '-f' or sys.argv[3] != 'd'):
        sys.stderr.write("ERROR: Incorrect Flags\n")
        exit(3)

# make sure that the directory in tmp exists, create it otherwise
def verifyTmp():
    if not os.path.exists(TMP_FOLDER):
        os.mkdir(TMP_FOLDER)

# create lists of filepaths of inputs
def parseArgs():

    # hold names of all filepaths to be compared
    fpaths1 = getPaths(sys.argv[1], sys.argv[2])
    fpaths2 = getPaths(sys.argv[3], sys.argv[4])

    return fpaths1, fpaths2

# obtains filepaths
def getPaths(flag, path):

    fpaths = list()

    if (flag == '-f'):
        fpaths.append(path)
    else:
        # obtains list of all the short names of files in directory
        fnames = os.walk(path)[2]
        print fnames
        # short names become full paths
        fpaths = [os.path.join(path, name) for name in fnames]
        print fpaths

    return fpaths


# clean the tmp directory by removing any tmp files in our tmp folder
def cleanTmp():
    shutil.rmtree(TMP_FOLDER)

# make sure the input is a real file
def verifyPathToFile(path):
    if not os.path.isfile(path):
        sys.stderr.write("ERROR: Path "+path+" is invalid/is not a file\n")
        exit(2)

# gets the format of the file based on size of sample and sample width
#  8 bits: size + "b"
# 16 bits: size + "h"
def getFormat(sampsize, sampwidth):
    fmt = str(sampsize)
    if sampwidth == 1:
        fmt = fmt + 'b'
    else:
        fmt = fmt + 'h'
    return fmt

# fft1 and fft2 are arrays of tuples of highest mags defined in
# createFingerprints
def compare(fft1, fft2):
    if len(fft1) <= len(fft2):
        return isSubset(fft1, fft2)
    else:
        return isSubset(fft2, fft1)

# assumes list1 is the child/subset
def isSubset(list1, list2):
    count = 0
    val1 = list1[0]

    for i2, val2 in enumerate(list2):
        # check if there are enough pieces for it to be a match
        if len(list1) > len(list2) - i2:
            break

        if distance(val1, val2) <= TOLERANCE:
            count = checkSequence(list1, list2, i2) + 1
            if closeRatio(count, len(list1)):
                return True

    return False

def checkSequence(list1, list2, ind):
    count = 0
    for i, j in enumerate(range(ind+1, len(list1)+ind)):
        if distance(list1[i+1], list2[j]) <= TOLERANCE:
            count = count + 1

    return count

# distance function that uses euclidean formula to get the
# distance between the two given tuples
# - assumes tuple1 and tuple2 are of the same size
def distance(tuple1, tuple2):
    underroot = 0
    for i in range(0, len(tuple1)): 
        underroot = underroot + math.pow(tuple1[i] - tuple2[i], 2)
    
    dist = math.sqrt(underroot)
    #print(dist)
    return dist

# creates tolerance for acceptance as a derived file using a ratio
def closeRatio(val1,val2):
    val1 = float(val1)
    val2 = float(val2)
    ratio = 1.0
    if val1 > val2:
        ratio = val2/val1
    else:
        ratio = val1/val2

    if ratio < PERCENT_RATIO:
        return False
    return True

if __name__ == '__main__':
    verifyArgs()
    verifyTmp()
    fpaths1, fpaths2 = parseArgs()

    allMatch(fpaths1, fpaths2)
    
    cleanTmp()
    exit(0)
